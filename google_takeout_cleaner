 #!/bin/bash

# A script to clean up Google Takeout files by correcting file extensions based on
# MIME type and ensuring metadata JSON files are named correctly.

# --- Configuration ---
# Set to "true" to run in dry-run mode (print commands without executing them)
DRY_RUN=false

# Define the log file
LOG_FILE="google_takeout_cleaner_error.log"

# Redirect stderr to the log file
exec 2>>"$LOG_FILE"

# --- Script Boilerplate ---
# Exit immediately if a command exits with a non-zero status.
set -e

# --- Helper Functions ---
function log() {
    echo "[INFO] $1"
}

function warn() {
    echo "[WARN] $1" >&2
}

function error() {
    echo "[ERROR] $1" >&2
    exit 1
}

function execute_mv() {
    local source="$1"
    local destination="$2"

    if [ "$source" == "$destination" ]; then
        # No need to move if paths are identical
        return
    fi

    if [ "$DRY_RUN" = true ]; then
        echo "  [DRY RUN] mv \"$source\" \"$destination\""
    else
        # Create destination directory if it doesn't exist (should not be needed with find)
        mkdir -p "$(dirname "$destination")"
        # Use -v for verbose output
        mv -v "$source" "$destination"
    fi
}

# --- Argument and Dependency Checks ---
if [ -z "$1" ]; then
    error "Usage: $0 <target_directory>"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' not found."
fi

if ! command -v exiftool &> /dev/null; then
    error "exiftool could not be found. Please install it first."
fi

if [ "$DRY_RUN" = true ]; then
    log "--- SCRIPT IS RUNNING IN DRY-RUN MODE ---"
    log "--- No files will actually be renamed. ---"
fi

# ==============================================================================
# PHASE 1: PRE-CLEANUP JSON FILES
# Fix common JSON naming issues first to simplify the main logic.
# ==============================================================================

log "--- Phase 1: Cleaning up JSON filenames ---"

# 1a: Rename `supplemental-meta.json` to `supplemental-metadata.json`
log "Step 1a: Searching for 'supplemental-meta.json' files to rename..."
find "$TARGET_DIR" -type f -name '*supplemental-meta.json' -print0 | while IFS= read -r -d $'\0' meta_file; do
    new_meta_file="${meta_file/supplemental-meta.json/supplemental-metadata.json}"
    log "Renaming abbreviated metadata file:"
    execute_mv "$meta_file" "$new_meta_file"
done

# 1b: Fix JSONs with misplaced parenthesis, e.g., `2014-02-03.jpg.supplemental-metadata(34).json`
log "Step 1b: Searching for JSON files with misplaced parenthesis..."
find "$TARGET_DIR" -type f -name '*).json' -print0 | while IFS= read -r -d $'\0' old_path; do
    old_name=$(basename "$old_path")
    old_dir=$(dirname "$old_path")

    # Regex to match: {prefix}.{extension}.supplemental-metadata({counter}).json
    if [[ "$old_name" =~ ^(.+)\.([a-zA-Z0-9]+)\.supplemental-metadata\(([0-9]+)\)\.json$ ]]; then
        prefix="${BASH_REMATCH[1]}"
        extension="${BASH_REMATCH[2]}"
        counter="${BASH_REMATCH[3]}"

        # Construct the correct name: {prefix}({counter}).{extension}.supplemental-metadata.json
        new_name="${prefix}(${counter}).${extension}.supplemental-metadata.json"
        new_path="${old_dir}/${new_name}"

        log "Fixing misplaced parenthesis in JSON filename:"
        execute_mv "$old_path" "$new_path"
    fi
done


# ==============================================================================
# PHASE 2: PROCESS MEDIA FILES AND SYNC METADATA
# Iterate over all non-JSON files.
# ==============================================================================

log "--- Phase 2: Processing media files and syncing metadata ---"
find "$TARGET_DIR" -type f -not -iname '*.json' -print0 | while IFS= read -r -d $'\0' media_path; do
    
    dir=$(dirname "$media_path")
    filename=$(basename "$media_path")
    log "Processing: $media_path"

    # --- Step 2a: Correct media file extension based on MIME type ---
    current_ext_lower=$(echo "${filename##*.}" | tr '[:upper:]' '[:lower:]')
    base_name="${filename%.*}"

    # Get the actual MIME type from exiftool
    mime_type=$(exiftool -s3 -MIMEType "$media_path")
    new_ext=""

    case "$mime_type" in
        "image/jpeg")
            if [[ "$current_ext_lower" != "jpg" && "$current_ext_lower" != "jpeg" ]]; then
                new_ext="jpg"
            fi
            ;;
        "image/png")
            if [[ "$current_ext_lower" != "png" ]]; then
                new_ext="png"
            fi
            ;;
        "image/gif")
            if [[ "$current_ext_lower" != "gif" ]]; then
                new_ext="gif"
            fi
            ;;
        "image/heic")
            if [[ "$current_ext_lower" != "heic" ]]; then
                new_ext="heic"
            fi
            ;;
        "video/mp4")
            if [[ "$current_ext_lower" != "mp4" ]]; then
                new_ext="mp4"
            fi
            ;;
        "video/quicktime")
            if [[ "$current_ext_lower" != "mov" ]]; then
                new_ext="mov"
            fi
            ;;
    esac

    # If an extension change is needed, rename the file
    if [ -n "$new_ext" ]; then
        new_media_path="${dir}/${base_name}.${new_ext}"
        if [ -e "$new_media_path" ]; then
            warn "  - SKIPPING rename of '$filename' to '${base_name}.${new_ext}' because destination already exists."
        else
            log "  - Correcting extension from '$current_ext_lower' to '$new_ext' based on MIME type '$mime_type'."
            execute_mv "$media_path" "$new_media_path"
            # IMPORTANT: Update our variables to use the new, correct path for the next step
            media_path="$new_media_path"
            filename=$(basename "$media_path")
        fi
    fi

    # --- Step 2b: Find and rename the corresponding metadata file to match perfectly ---
    # The expected metadata filename, based on the (now correct) media filename.
    expected_meta_path="${media_path}.supplemental-metadata.json"

    if [ -f "$expected_meta_path" ]; then
        log "  - Metadata file is already correctly named."
        continue # Move to the next media file
    fi

    # The metadata file is not named correctly. Let's find it.
    # The pre-cleanup phase should have fixed most issues, so we're likely looking
    # for a file with a case mismatch or an old extension mismatch.
    base_name_no_ext="${filename%.*}"
    
    # Use find to locate potential candidates case-insensitively
    # We search for any json file that starts with the base name and ends with the metadata suffix.
    mapfile -t candidate_files < <(find "$dir" -maxdepth 1 -type f -iname "${base_name_no_ext}.*.supplemental-metadata.json")
    if [ "${#candidate_files[@]}" -eq 1 ]; then
        # Exactly one candidate found, this is our file.
        found_meta_path="${candidate_files[0]}"
        if [ "$found_meta_path" != "$expected_meta_path" ]; then
            log "  - Found mismatched metadata file, syncing name:"
            execute_mv "$found_meta_path" "$expected_meta_path"
        fi
    elif [ "${#candidate_files[@]}" -gt 1 ]; then
        # More than one candidate, we can't be sure which one is correct.
        warn "  - Found multiple possible metadata files for '$filename'. Please resolve manually."
        for candidate in "${candidate_files[@]}"; do
            warn "    - Candidate: $candidate"
        done
    else
        # No metadata file found at all.
        log "  - No supplemental metadata file found for '$filename'."
    fi

done

log "--- Cleanup Complete ---"